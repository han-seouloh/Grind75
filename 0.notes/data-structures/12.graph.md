# Graph
This is a non-linear data structure that consists of a finite number of vertices (also called nodes) connected by edges. Trees are a specific type of graphs.
There are no hierarchies in graphs nor a set way of reading them.

## Types of Graphs
- **Directed**: Graphs in which the edges have a direction and its edges are usually represented by arrows pointing in the direction the graph can be traversed.
- **Undirected**: Graphs in which the edges are bidirectional. The graph can be traversed in either direction. The absence of an arrow tells us that the graph is undirected.
- Can be made up of only vertices without edges.
- Multiple edges from one node.
- Cycles in the graph.
- Self-loops on a node.
- Disconnected/singled out nodes.
- May have weighted edges.

## Examples of Use
- Google Maps (Cities as vertices and roads as edges)
- Social media sites (Users are vertices and links as edges)

## Implementation
Graphs are represented in two ways:
- Adjacency matrix:
  - a 2D array of size VxV where V is the number of vertices in the graph.
  - Each row and column represent a vertex.
  - If the value of any element, matrix[i][j] is 1, it represents that there is an edge connecting vertex i and vertex j.
  - The matrix below represents an undirected graph where A - B - C.

      |   | A | B | C |
      | - | - | - | - |
      | A | 0 | 1 | 0 |
      | B | 1 | 0 | 1 |
      | C | 0 | 1 | 0 |

      ```js
      const adjacencyMatrix = [
        [0, 1, 0],
        [1, 0, 1],
        [0, 1, 0]
      ];
      ```

- Adjacency list:
  - Vertices are stored in a map like data structure, and every vertex stores a list of its adjacent vertices.
    ```js
    // A -> [B]
    // B -> [A, C]
    // C -> [B]

    const adjacencyList = {
      'A': ['B'],
      'B': ['A', 'C'],
      'C': ['B']
    }
    ```

This implementation of graphs will assume an adjacency list representation of graphs.
```js

```

## Adjacency Matrix vs Adjacency List
**Matrix**:
  - Store values regardles of whether an edge exists or not.
  - Inserting and finding adjacent nodes is in linear time.
  - Additional values such as weights have to be stored externally.

**List**:
  - Only need to store the values for the edges that exists. (More efficient storage)
  - Inserting and finding adjacent nodes can be done in constant time. (Insertion and search is more efficient)
  - Allows you to store additional values with an edge such as weights.